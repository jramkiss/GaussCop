% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xDensity.R
\name{xDensity}
\alias{xDensity}
\alias{dXD}
\alias{pXD}
\alias{qXD}
\alias{rXD}
\title{Implementation of \code{d/p/q/r} functions for \code{xDensity} distributions.}
\usage{
dXD(x, xDens, log = FALSE)

pXD(q, xDens, lower.tail = TRUE, log.p = FALSE)

qXD(p, xDens, lower.tail = TRUE, log.p = FALSE)

rXD(n, xDens)
}
\arguments{
\item{x, q}{Vector of quantiles.}

\item{xDens}{Object of class \code{xDensity} representing the distribution.}

\item{log, log.p}{Logical; if \code{TRUE}, probabilities \code{p} are given as \code{log(p)}.}

\item{lower.tail}{Logical; if \code{TRUE} (default), probabilities are \code{P[X <= x]} otherwise, \code{P[X > x]}.}

\item{p}{Vector of probabilities.}

\item{n}{Number of observations.}
}
\value{
For the underlying \code{xDensity} object, \code{dXD} gives the density, \code{pXD} gives the distribution function, \code{qXD} gives the quantile function and \code{rXD} generates \code{n} random values.
}
\description{
Implementation of \code{d/p/q/r} functions for \code{xDensity} distributions.
}
\details{
Extended density (or \code{xDensity}) objects provide a compact representation of arbitrary one-dimensional distributions defined on the real line.  That is, an \code{xDensity} object is a list with the following elements:
\itemize{
  \item \code{xrng}, \code{ndens}: range and number of gridpoints defining the main density region, i.e. \code{xseq = seq(xrng[1], xrng[2], len = xn)}.
  \item \code{ypdf}, \code{ylpdf}, \code{ycdf}: density, log-density, and cdf on the grid.
  \item \code{mean}, \code{sd}: mean and standard deviation of a Normal distribution to use outside the specified density range.
}
}
\examples{
nsamples <- 1e5
X <- rnorm(nsamples) # generate data
xDens <- kernelXD(X) # Use kernel constructor to construct xDens object

# pdf and sampling check
Xsim <- rXD(nsamples, xDens = xDens) # xDensity sampling using rXD
hist(Xsim, breaks = 100, freq = FALSE,
     xlab = "x", main = "PDF")
curve(dXD(x, xDens = xDens), add = TRUE, col = "red") # xDensity PDF
curve(dnorm(x), add = TRUE, col = "blue") # true PDF
abline(v = xDens$xrng, lty = 2) # grid endpoints
legend("topright", c("rXD", "dXD", "N(0,1)", "xRange"),
       pch = c(22,22,22,NA), pt.cex = 1.5,
       pt.bg = c("white", "red", "blue", "black"),
       lty = c(NA, NA, NA, 2))

# cdf check
curve(pXD(x, xDens), # xDensity CDF
      from = min(Xsim), to = max(Xsim), col = "red",
      xlab = "x", main = "CDF", ylab = "Cumulative Probability")
curve(pnorm(x), add = TRUE, col = "blue") # true CDF
abline(v = xDens$xrng, lty = 2) # grid endpoints
legend("bottomright", c("pXD", "N(0,1)", "xRange"),
       pch = c(22,22,NA), pt.cex = 1.5,
       pt.bg = c("red", "blue", "black"),
       lty = c(NA, NA, 2))

# quantile check
curve(qXD(x, xDens), # xDensity quantile function
      from = 0, to = 1, col = "red",
      xlab = "Quantiles", main = "Quantile Plot", ylab = "x")
curve(qnorm(x), add = TRUE, col = "blue") # true CDF
legend("bottomright", c("qXD", "N(0, 1)"),
       pch = c(22,22,NA), pt.cex = 1.5,
       pt.bg = c("red", "blue"),
       lty = c(NA, NA, 2))
}
\seealso{
\code{\link{matrixXD}}, \code{\link{kernelXD}}, \code{link{gc4XD}} for various \code{xDensity} object constructors.
}
