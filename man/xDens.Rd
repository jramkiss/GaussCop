% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xDens.R
\name{xDens}
\alias{xDens}
\alias{dXD}
\alias{pXD}
\alias{qXD}
\alias{rXD}
\title{Calculation of \code{d/p/q/r} functions for density approximations.}
\usage{
dXD(x, xDens, log = FALSE)

pXD(q, xDens, lower.tail = TRUE, log.p = FALSE)

qXD(p, xDens, lower.tail = TRUE, log.p = FALSE)

rXD(n, xDens)
}
\arguments{
\item{x, q}{Vector of quantiles.}

\item{xDens}{Object containing the extended-density (\code{xDens}) representation.}

\item{log, log.p}{Logical; if \code{TRUE}, probabilities \code{p} are given as \code{log(p)}.}

\item{lower.tail}{Logical; if \code{TRUE} (default), probabilities are \code{P[X <= x]} otherwise, \code{P[X > x]}.}

\item{p}{Vector of probabilities.}

\item{n}{Number of observations.}
}
\value{
For the underlying \code{xDens} object, \code{dXD} gives the density, \code{pXD} gives the distribution function, 
\code{qXD} gives the quantile function and \code{rXD} generates \code{n} random values.
}
\description{
Extended Density, \code{xDens}, objects provide a unified framework for the calculation of R's standard \code{d/q/p/r} functions
for unconstrained density approximations of a finite set of values. See the `constructors` section of the vignette 
for more information on the construction of \code{xDens} objects.
}
\details{
An \code{xDens} object is a list with the following elements:
\itemize{
  \item \code{xrng}, \code{ndens}: range and number of gridpoints defining the main density region, i.e. \code{xseq = seq(xrng[1], xrng[2], len = xn)}.
  \item \code{ypdf}, \code{ylpdf}, \code{ycdf}: density, log-density, and cdf on the grid.
  \item \code{mean}, \code{sd}: mean and standard deviation of a Normal distribution to use outside the specified density range.
}
}
\examples{
nsamples <- 1e5
X <- rnorm(nsamples) # generate data
xDens <- kernelXD(X) # Use kernel constructor to construct xDens object

# pdf and sampling check
Xsim <- rXD(nsamples, xDens = xDens) # xDensity sampling using rXD
hist(Xsim, breaks = 100, freq = FALSE,
     xlab = "x", main = "PDF")
curve(dXD(x, xDens = xDens), add = TRUE, col = "red") # xDensity PDF
curve(dnorm(x), add = TRUE, col = "blue") # true PDF
abline(v = xDens$xrng, lty = 2) # grid endpoints
legend("topright", c("rXD", "dXD", "N(0,1)", "xRange"),
       pch = c(22,22,22,NA), pt.cex = 1.5,
       pt.bg = c("white", "red", "blue", "black"),
       lty = c(NA, NA, NA, 2))

# cdf check
curve(pXD(x, xDens), # xDensity CDF
      from = min(Xsim), to = max(Xsim), col = "red",
      xlab = "x", main = "CDF", ylab = "Cumulative Probability")
curve(pnorm(x), add = TRUE, col = "blue") # true CDF
abline(v = xDens$xrng, lty = 2) # grid endpoints
legend("bottomright", c("pXD", "N(0,1)", "xRange"),
       pch = c(22,22,NA), pt.cex = 1.5,
       pt.bg = c("red", "blue", "black"),
       lty = c(NA, NA, 2))

# quantile check
curve(qXD(x, xDens), # xDensity quantile function
      from = 0, to = 1, col = "red",
      xlab = "Quantiles", main = "Quantile Plot", ylab = "x")
curve(qnorm(x), add = TRUE, col = "blue") # true CDF
legend("bottomright", c("qXD", "N(0, 1)"),
       pch = c(22,22,NA), pt.cex = 1.5,
       pt.bg = c("red", "blue"),
       lty = c(NA, NA, 2))
}
